<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Dropwizard | From Shakespeare to Java]]></title>
  <link href="http://LCBecker.github.io/blog/categories/dropwizard/atom.xml" rel="self"/>
  <link href="http://LCBecker.github.io/"/>
  <updated>2015-11-18T21:32:05-05:00</updated>
  <id>http://LCBecker.github.io/</id>
  <author>
    <name><![CDATA[Lori Becker]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[DropWizard Metrics 101]]></title>
    <link href="http://LCBecker.github.io/blog/2015/11/18/dropwizard-metrics-101/"/>
    <updated>2015-11-18T18:18:54-05:00</updated>
    <id>http://LCBecker.github.io/blog/2015/11/18/dropwizard-metrics-101</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/metrics.jpg" title="&lsquo;metrics art&rsquo; &lsquo;metrics art&rsquo;" ></p>

<h6>IO Graph Art by <a href="http://www.flickr.com/photos/nathanmac87/4415951740">nathanmac87</a></h6>

<p>My most recent project at work has been to utilize DropWizard metrics to gather information about an application I built and send that data to Graphite to display in a realtime dashboard. As I normally do, I reviewed the documentation for <a href="https://dropwizard.github.io/metrics/3.1.0/getting-started/">Dropwizard Metrics</a>, but as usual, there was a lot to be desired. Their example did not go into the nitty gritty of <em>how</em> to connect everything together. The internet was also silent on how to actually use DropWizard metrics.</p>

<p>So here is my tutorial on how <em>I</em> was able to get DropWizard metrics up and running in my application:</p>

<h3>1. Maven Application? Update pom.xml</h3>

<p>If you&rsquo;ve got a Maven application, you&rsquo;ll need to add metrics-core as a dependency. If you&rsquo;re using some sort of special reporter like Graphite, you may need to add an additional dependency. This was what I had to add to my pom:</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;io.dropwizard.metrics&lt;/groupId&gt;
    &lt;artifactId&gt;metrics-core&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.dropwizard.metrics&lt;/groupId&gt;
    &lt;artifactId&gt;metrics-graphite&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h3>2. Make a Metrics Class</h3>

<p>The metrics class we&rsquo;re going to create is going to have a <code>MetricRegistry</code> object that will manage all of our metrics (these are timers, counters, meters, histograms, and gauges). The metrics class has a method to retrieve the <code>MetricRegistry</code> because this is needed to register the meters we will define in our Resources class(es). Finally, it contains a method to report what all of our metrics collect to some output. I sent my data to Graphite. Note that the <code>prefixedWith</code> is not really necessary. What this does is append a label in front of our metrics names. I&rsquo;ll explain this more in Step 3.  This is what my Metrics class looked like:</p>

<pre><code>import java.net.InetSocketAddress;
import java.util.concurrent.TimeUnit;
import com.codahale.metrics.MetricFilter;
import com.codahale.metrics.MetricRegistry;
import com.codahale.metrics.graphite.Graphite;
import com.codahale.metrics.graphite.GraphiteReporter;

public class MyAppMetrics() {
    static final MetricRegistry metrics = new MetricRegistry();

    public static MetricRegistry getRegistry() {
        return metrics;
    }

    public static void startReport() {
        final Graphite graphite = new Graphite(new InetSocketAddress("your.graphite.com", 2003));
        final GraphiteReporter reporter = GraphiteReporter.forRegistry(metrics)
        .prefixedWith("upToYou")
        .convertRatesTo(TimeUnit.SECONDS)
        .convertDurationTo(TimeUnit.MILLISECONDS)
        .filter(MetricFilter.ALL)
        .build(graphite);
        reporter.start(1, TimeUnit.MINUTES);
    }
}
</code></pre>

<h3>3. Add Metrics To Your Resources</h3>

<p>I wanted metrics like &lsquo;How many requests are we getting at /path1&rsquo; and &lsquo;How long is it taking for the method handling /path1 to return a response&rsquo;. Chances are you are, too. In order to do this, we&rsquo;ll need to add metrics to our resources. And those metrics need to be &ldquo;saved&rdquo; in the <code>MetricRegistry</code> from Step 2. So we&rsquo;ll need to create a constructor for our resource that will take in the <code>MetricRegistry</code> object we&rsquo;ve got in our metrics class. In addition, we will need to instantiate our metrics inside your Resources constructor. And finally, we need to link those metrics to a method in our resource. Take a look at the following code:</p>

<pre><code>public class MyResource {
     MetricRegistry metrics;
     Meter requestCount;

     public MyResource(MetricRegistry registry) {
        this.metrics = registry;
        requestCount = metrics.meter(MetricRegister.name("requestCount"));
     }

     @POST
     @Path("/path1")
     @Produces(MediaType.TEXT_PLAIN)
     @Metered(name="requestCount")
     public Response handleRequest() {
        requestCount.mark();
        return Response.ok("Hello World").build(); //you know what I mean...
     }
}
</code></pre>

<p>Notice these details:</p>

<ul>
<li>We declare the meter <code>requestCount</code>, which will give us the total count of all calls made to /path1 and how many requests /path1 gets in 1 minute, 5 minute, and 15 minute timeframes. This meter is initialized in our Resource constructor, but you could put it in some sort of <code>init()</code> method if you prefer. It&rsquo;s initialization uses our <code>MetricRegistry</code> so it can manage it accordingly.</li>
<li>Next, we&rsquo;ve placed the annotation <code>@Metered(name="requestCount")</code> above the method we&rsquo;d like to monitor. The name part is just that, a name. Remember in Step 2 when we saw that <code>.prefixedWith("upToYou")</code>? Basically, our reporter, whether Graphite or the console or something else, will refer to this metric by the prefix + name of the metric. Graphite showed me options to graph like, &ldquo;upToYou.requestCount.count&rdquo; and &ldquo;upToYou.requestCount.mean&rdquo; (the &lsquo;count&rsquo; and &lsquo;mean&rsquo; part are automatically attached by DropWizard metrics). You don&rsquo;t need any prefix, but if you want it, go for it.</li>
<li>Finally, we call our meter&rsquo;s <code>mark()</code> method. That tells the metric, &ldquo;Hey, the method we&rsquo;re tracking has been called! Increment the meter count!&rdquo; The <code>mark()</code> method is for the meter metric, though. Please refer to the <a href="https://dropwizard.github.io/metrics/3.1.0/getting-started/">DropWizard Metrics</a> documentation on how to initialize and call counters, histograms, and other metrics.</li>
</ul>


<h3>4. Start Your Metrics On Application Startup</h3>

<p>We&rsquo;ve almost come full circle! The last step is to simply provide our <code>MetricRegistry</code> in our Metrics class to our Resource and get our metrics to be on the lookout when we start our application. In the <code>run()</code> method in our <code>Application</code> class:</p>

<pre><code>environment.jersey().register(new com.example.resource.MyResource(MyAppMetrics.getRegistry()));
MyAppMetrics.startReport();
</code></pre>

<p>Now, when we start up our application, our metrics will be monitoring what we want and sending data to the console or Graphite or wherever!</p>

<p>So, there you have it! This is how everything ties together in DropWizard Metrics! And I&rsquo;m the first person to actually write an example of this! Woohoo! I hope you have enjoyed this post and that it&rsquo;s given you a decent amount of confidence to use DropWizard metrics in your application! Happy Coding!</p>

<p>If you really like this, tell me on Twitter @LBeckerCodes !</p>
]]></content>
  </entry>
  
</feed>
